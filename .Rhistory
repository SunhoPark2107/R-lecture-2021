# decision tree의 정확도 체크하는 방법
t <- table(pred_dtu, ucla_test$admit)
dt_acc <- (t[1,1] + t[2,2])/nrow(ucla_test)
# decision tree의 정확도 체크하는 방법
t <- table(pred_dtu, ucla_test$admit)
dt_acc <- (t[1,1] + t[2,2])/nrow(ucla_test)
source('C:/workspace/R/단원문제 Markdown/0503 분류모델 4종 연습 마크다운/분류모델 4종 연습 풀이장.R', encoding = 'UTF-8', echo=TRUE)
library(class)
source('C:/workspace/R/단원문제 Markdown/0503 분류모델 4종 연습 마크다운/분류모델 4종 연습 풀이장.R', encoding = 'UTF-8', echo=TRUE)
r <- table(pred_rfu, ucla_test$admit)
rf_acc <- (r[1,1] + r[2,2])/nrow(ucla_test)
rf_acc
source('C:/workspace/R/단원문제 Markdown/0503 분류모델 4종 연습 마크다운/분류모델 4종 연습 풀이장.R', encoding = 'UTF-8', echo=TRUE)
# 로지스틱 회귀
lr <- glm(admit ~ . , ucla_train, family = binomial)
t <- table(lr_pred, ucla_test$admit)
lr_acc <- (t[1,1], t[2,2]) / nrow(ucla_test)
# 로지스틱 회귀
lr <- glm(admit ~ . , ucla_train, family = binomial)
lr_pred <- predict(lr, ucla_test, type = 'response')
lr_pred
lr_pred <- ifelse(lr_pred > 0.5, 1, 0)
t <- table(lr_pred, ucla_test$admit)
lr_acc <- (t[1,1], t[2,2]) / nrow(ucla_test)
lr_acc
lr_acc <- (t[1,1] + t[2,2]) / nrow(ucla_test)
lr_acc
wine <- read.table('data/wine.data.txt', sep = ',')
########################################### Wine 데이터 가져와서 가공###############################################
getwd()
wetwd("C:/workspace/R")
setwd("C:/workspace/R")
wine <- read.table('data/wine.data.txt', sep = ',')
head(wine)
columns <- readLines('data/wine.name.txt')
columns
names(wine)               # V1 은 얻고자 하는 결과. 따라서 2번째 열부터 columns의 변수명을 적용하여 줌.
names(wine) [2:14] <- columns
source('C:/workspace/R/단원문제 Markdown/0503 분류모델 4종 연습 마크다운/분류모델 4종 연습 풀이장.R', encoding = 'UTF-8', echo=TRUE)
print(paste(dt_acc, rf_acc, sv_acc, kn_acc, lr_acc))
# svm 모델 정확도 평가
s <- table(pred_svmu, ucla_test$admit)
sv_acc <- (r[1,1] + r[2,2])/nrow(ucla_test)
sv_acc
# k-nn 모델 정확도 평가
k <- table(knn_u, ucla_test$admit)
kn_acc <- (r[1,1] + r[2,2])/nrow(ucla_test)
kn_acc
print(paste(dt_acc, rf_acc, sv_acc, kn_acc, lr_acc))
columns <- readLines('data/wine.name2.txt')
columns
names(wine)               # V1 은 얻고자 하는 결과. 따라서 2번째 열부터 columns의 변수명을 적용하여 줌.
names(wine) [2:14] <- columns
names(wine)
names(wine)[2:14] <- substr(columns, 4, nchar(columns))     # [1] V1 이런 식으로 되어 있으므로 이름만 남기기 위해서 substr함수 사용.
names(wine)
names(wine)[1] <- 'Y'
names(wine)
wine$Y <- factor(wine$Y)
t <- table(pred_dtw, ucla_test$Y)
t <- table(pred_dtw, wine_test$Y)
dtw_acc <- (t[1,1] + t[2,2])/nrow(wine_test)
s <- table(pred_svmu, ucla_test$admit)
sv_acc <- (s[1,1] + s[2,2])/nrow(ucla_test)
sv_acc
k <- table(knn_u, ucla_test$admit)
kn_acc <- (k[1,1] + k[2,2])/nrow(ucla_test)
kn_acc
print(paste(dt_acc, rf_acc, sv_acc, kn_acc, lr_acc))
sw <- table(pred_svmw, wine_test$Y)
rfw_acc <- (sw[1,1] + sw[2,2])/nrow(wine_test)
print(paste(dtw_acc, rfw_acc, sw_acc, kw_acc))
tw <- table(pred_dtw, wine_test$Y)
dtw_acc <- (tw[1,1] + tw[2,2])/nrow(wine_test)
rw <- table(pred_rfw, wine_test$Y)
rfw_acc <- (rw[1,1] + rw[2,2])/nrow(wine_test)
sw <- table(pred_svmw, wine_test$Y)
sw_acc <- (sw[1,1] + sw[2,2])/nrow(wine_test)
kw <- table(knn_w, wine_test$Y)
kw_acc <- (kw[1,1] + kw[2,2])/nrow(wine_test)
print(paste(dtw_acc, rfw_acc, sw_acc, kw_acc))
lrw <- glm(Y ~ . , wine_train, family = binomial)
lrw_pred <- predict(lr, wine_test, type = 'response')
lrw_pred
lrw_pred <- ifelse(lrw_pred > 0.5, 1, 0)
tw <- table(lrw_pred, wine_test$Y)
lrw_acc <- (t[1,1] + t[2,2]) / nrow(wine_test)
lrw_acc
print(paste(dtw_acc, rfw_acc, sw_acc, kw_acc, lrw_acc))
