# 벡터(Vector, 1차원 데이터)  c함수: 일반 벡터 생성 seq함수: 순열 벡터 생성
# 벡터란? => 여러 개의 값을 하나의 변수로 저장한 것. / 단일값들의 모음.
s <- c(1,2,3,4,5,6)
s2 <- c(1:6)   # 2줄 3줄은 동일한 내용. 시작:끝
s3 <- c(6:1)
s4 <- 1:5      # 일반적인 순서로 할 때에는 c 안 붙여 줘도 된다.
c(1:3, c(4:6))
c(1:30)
seq(1, 100, by=2)     # from, to, increment
seq(from=100, to=1, by=-3)
seq(0, 1, by=0.1)
seq(0, 1, length.out=11)

rep(c(1:3), times=2)    # 1 2 3 1 2 3
rep(c(1:3), each=2)     # 1 1 2 2 3 3

# 인덱싱(Indexing)
x <- seq(2,10,by=2)
x[1]                  # 시작 수가 1인 프로그래밍 언어는 R밖에 없음. (다른 건 0부터 시작.)
x[-1]                 # 여기에서 -1 의미는 첫 번째 것을 "제외한(배제한)" 나머지 이다.
x[-3]                 # -3의미는 3번째 수를 제외한 나머지 이다.

#slicing           원하는 값만 추출하기.
x[1:3]             
x[c(1, 3, 5)]
x[-c(2,4)]

# 연산
x <- c(1:4)
y <- c(5:8)
z <- c(3,4)
w <- c(5:7)

x + 2     # 3 4 5 6
x + y     # 6 8 10 12
x + z     # 벡터의 길이가 다를 때의 연산 : 1, 2에 3, 4를 더하고, 3, 4에 다시 3, 4를 더함.
x + w     # warning message 뜨긴 하지만, 기본적으로 짧은 쪽이 돌아가면서 더해짐.

length(w)


x > 2
all(x>2)   # x벡터의 모든 값이 2보다 큰가? (AND)
any(x>2)   # x벡터 중에 2보다 큰 값이 하나라도 있는가? (OR)

# fnacy indexing
y[x>2]     # y벡터에서 3, 4번째 값을 가져와라 (x>2인 3, 4)

x <- 1:10
head(x)
head(x, 3)
tail(x)
tail(x, 5)

# 집합 연산

x <- 1:3
y <- 3:5
z <- c(3,1,2)

union(x, y)       # 합집합
intersect(x, y)   # 교집합
setdiff(x, y)     # 차집합(x벡터에서 y벡터와 겹치는 것만 제외.)
setdiff(y, x)
setequal(x, y)    # x와 y의 요소가 같은가? (답: false)
setequal(x, z)    # T

# mark down
# R로 코드를 만들었다면, 적절하게 텍스트 추가하여 계단식으로 배열하면 그 자체로 보고서가 완성됨
# 이후 html 파일로 변환할 수 있음.

install.packages("rmarkdown")
install.packages("knitr")


# p. 90 연습 문제

# 1번 문제

x <- c(1:5)
x <- c(x, c(6:10))

# 2번 문제

# 첫 번째 시도(seq from to by 문법)
x <- c(1:10)
x <- seq(from=2, to=10, by=2)    # 이렇게 해도 되는거 맞나?

# 두 번째 시도(length.out 활용한 방법)
x <- c(1:10)
x <- seq(2, 10, length.out = 5)   #?? 시작을 2부터 해도 되는건가?

# 세 번째 시도(홀수 값만을 저장하는 임의의 벡터 하나 만든 후 차집합(setdiff) 활용.)
x <- c(1:10)
S5 <- c(seq(1,9,2))
x <- c(setdiff(x,S5))             # 답은 완성하였으나 문제해결 코드가 2줄이 됨.

# 네 번째 시도(단순히 그냥 1~9까지 홀수 값 직접 입력하여 제외하고 출력)
x <- c(1:10)
x <- x[-c(1,3,5,7,9)]             # 답은 되지만... 이렇게 할거면 직접 손으로 쳤지...

# 다섯 번째 시도(%%연산자 통해 2로 나눈 나머지 0 ==로 좌우값 일치 체크 하여 짝수만 남기기.)
x <- c(1:10)
x <- x[x%%2==0]                       # 실수노트) 논리연산자 ==와 일반 등호 착각하지 않기.

# 답지...내가 1트 2트 한거랑 똑같이 한거 아닌가... 굳이 length로 쓰는 이유는 무엇이지
x <- c(1:10)
x <- x[seq(2,length(x),2)]


# p. 112 단원문제

# 1번 문제
x <- c(1:100)
x <- x[x%%3==0]
y <- c(1:100)
y <- y[y%%4==0]

# 2번 문제
# R에서도 sum 함수를 사용할 수 있었다.. ㅠㅠ 
intersect(x, y)
sum(intersect(x, y))     # R에서도 sum함수를 사용할 수 있구나... 왜 구글링할땐 안나와악



















